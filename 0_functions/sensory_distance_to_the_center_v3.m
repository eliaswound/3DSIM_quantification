% This script is for Quynh to calculate the distance from the sensory position to the center of the cell  
clear;close all;clc;
folder=uigetdir('Please select the folder that contains all the sensoryposition_generateddata.mat file generated by ALI_basalbody_analysis_Main');
cd(folder);
%--------------------------------------------------------------------------
% Identify the corresponding files 
%--------------------------------------------------------------------------
files_sensory = dir([folder '\*_sensoryposition_generateddata.mat']);
if isempty(files_sensory)
    display('no sensoryposition files identified under the current folder')
end
files_contour=dir([folder '\*_basalnumberfunction_generateddata.mat']);
if isempty(files_contour)
    display('no contour files identified under the current folder')
end
%--------------------------------------------------------------------------
% File Matching
%--------------------------------------------------------------------------
match_index=[];
for i=1:length(files_sensory)
   sensory_name=files_sensory(i).name(1:end-35); 
   for j=1:length(files_contour)
       contour_name=strcat(files_contour(j).name(1:end-45),files_contour(j).name(end-40:end-39));
       tf=strcmpi(sensory_name,contour_name);
       if tf ==1
          match_index=[match_index;i,j];
       end      
   end
end
display('Matching Finished')

files_sensory_matched=files_sensory(match_index(:,1));
files_contour_matched=files_contour(match_index(:,2));


%--------------------------------------------------------------------------
% Sensory cilia position
%--------------------------------------------------------------------------
sensory_centroid_distance=[];
normalized_x=[];
normalized_y=[];
radius_all=[];
catch_sequence=[];
x_distance_all=[];
y_distance_all=[];
distance_all=[];
translate_direction_all=[];
cell_direction_all=[];
center_all=[];
for i=1:length(files_sensory_matched)
    try
    data=importdata(files_sensory_matched(i).name);
    x_distance=data.x_distance(1);
    x_distance_all=[x_distance_all;data.sensory_x(1)];
    y_distance=data.y_distance(1);
    y_distance_all=[y_distance_all;data.sensory_y(1)];
    distance=(x_distance^2+y_distance^2)^0.5;
    distance_all=[distance_all;distance];
    sensory_centroid_distance=[sensory_centroid_distance;distance];
    x_distance_norm=data.x_distance_norm(1);
    y_distance_norm=data.y_distance(1)/data.heighth;
    normalized_x=[normalized_x;x_distance_norm];
    normalized_y=[normalized_y;y_distance_norm];
    width=data.width;
    height=data.heighth;
    radius=(width+height)/4;
    radius_all=[radius_all;radius];
    translate_direction_all=[translate_direction_all;data.translate_direction];
    cell_direction_all=[cell_direction_all,data.cell_direction];
    center=[(data.b+1)/2,(data.a+1)/2];
    center_all=[center_all;center];
    catch
     catch_sequence=[sequence;i];
   end   
end
%--------------------------------------------------------------------------
% The contour of the cell
%--------------------------------------------------------------------------
contour=cell(length(files_contour_matched),2);
for i=1:length(files_contour_matched)
    try
    data=importdata(files_contour_matched(i).name);
    x=[];
    y=[];
    s=data.s;
    for k = 1 : data.numObj
    x=[x;s(k).WeightedCentroid(1)];
    y=[y;s(k).WeightedCentroid(2)];
    end
    coordinates=[x,y];
    [K,v] = convhull(x,y);
    contour{i,1}=[x(K),y(K)];
% calculate the long axis and short axis of the cell
    p=polyfit(x,y,1);
    slope=atan(p(1)); % slope in radian
    center_x=mean(x);
    center_y=mean(y);
    if slope>=0
        angle=pi/2-slope;
    else
        angle=-pi/2-slope;
    end
    rotated_coords = rotation([x,y],[center_x,center_y],angle,'radians');
    x_rotate=rotated_coords(:,1);
    y_rotate=rotated_coords(:,2);
    xmin=min(x_rotate);
    xmax=max(x_rotate);
    ymin=min(y_rotate);
    ymax=max(y_rotate);
    range=[xmax-xmin,ymax-ymin];
    contour{i,2}=range;  
    end   
    
    contour_dots=contour{i,1};
    contour_dots=[contour_dots;contour_dots(1,:)];
    index=1:1:length(contour_dots);
    indexi=1:0.01:length(contour_dots);
    x_insert=interp1(index,contour_dots(:,1),indexi, 'PCHIP');
    y_insert=interp1(index,contour_dots(:,2),indexi, 'PCHIP');
    contour{i,3}=[x_insert',y_insert'];
    clear contour_dots index indexi x_insert y_insert
    
end

% Add the translation and rotation part 
% Contour(i,4):translated coordinates
% Contour(i,5):translated and rotated coordinates
for i=1:length(contour)
    x_insert_translate=contour{i,3}(:,1)+translate_direction_all(i,1); % To be confirmed
    y_insert_translate=contour{i,3}(:,2)+translate_direction_all(i,2); % To be confirmed
    contour{i,4}(:,1)=x_insert_translate;
    contour{i,4}(:,2)=y_insert_translate;  
    coordinates=[x_insert_translate,2*center_all(i,2)-y_insert_translate]; % flip y for rotation  
    translate_rotation=rotation(coordinates,center_all(i,1:2),cell_direction_all(i));
    translate_rotation(:,2)=2*center_all(i,2)-translate_rotation(:,2);
    contour{i,5}=translate_rotation;
    clear x_insert_translate y_insert_translate
end
% calculate the average of the long axis and short axis
% calculate the sensory distance to the contour
  outbounds=find(normalized_x<-0.5|normalized_y<-0.5|normalized_x>0.5|normalized_y>0.5);
  normalized_x(outbounds)=[];
  normalized_y(outbounds)=[];
  x_distance_all(outbounds)=[];
  y_distance_all(outbounds)=[];
  distance_all(outbounds)=[];
  contour(outbounds,:)=[];
  
mkdir('sensory distance to cell center')  
cd('sensory distance to cell center')
for i=1:length(contour)
   figure(1000);clf;
   plot(contour{i,3}(:,1),contour{i,3}(:,2),'k.')
   hold on
   plot(contour{i,5}(:,1),contour{i,5}(:,2),'r.')
   plot(x_distance_all(i,1),y_distance_all(i,1),'*')
   
   axis equal
   saveas(figure(1000),[num2str(i) '_.png'],'png');
   
end
